# 软件设计模式

## 1 软件设计原则

### 1.1 开闭原则

对扩展开放，对修改关闭，对程序进行扩展时，不能去修改原来的代码，而是扩展原来的代码，案例搜狗换肤

### 1.2 里氏替换原则

原则：任何基类可以出现的地方，子类一定可以出现。通俗理解，子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，出了添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法完成新的功能，写起来简单，但是整个继承体系复用性差，当多态使用频繁时，程序运行出错概率教大。案例 正方形不是长方形

### 1.3 依赖倒转原则

高层模块不应该依赖低层模块，两者应该依赖其抽象，抽象不应该依赖细节，细节应该依赖于抽象， 简单来说就是对抽象进行编程，不要对实现进行编程，这样就降低了模块之间的耦合。设计类时，不与具体类交互，而与具体类的上层接口交互。案例 组装电脑

### 1.4 接口隔离原则

每个接口中不写子类用不大却必须实现的方法，如果出现，使用多个隔离接口，比使用单个接口要好。

### 1.5 迪米特法则（最少知道原则）

一个类对自己依赖的类知道的越少越好，也就是被依赖的类再复杂，都应该将逻辑封装在方法的内部，通过public 提供给外部，这样被依赖的类变化时，才能最小影响该类

### 1.6 合成复用原则

尽量使用合成/聚合方式，而不适用继承

## 2 软件设计模式分类

### 2.1创建型模式

#### 2.1.1工厂方法模式

**问题：**简单工厂模式存在，类的创建依赖工厂类，想要扩展程序，必须对工厂类进行修改，违背闭包。

**解决：**工厂方法模式，创建工厂接口和多个工厂实现类，增加新功能，直接增加新的工厂类就可以了，不需要修改之前代码。扩展性较好，无需对之前代码进行修改。

#### 2.1.2抽象工厂模式

**区别：**

工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类只能创建一个具体产品类的实例。 

抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品

工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。

抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。

#### 2.1.3单例模式

保证只有一个实例存在

**优点：** 

1.某些类创建比较频繁，开销很大

2.降低内存使用频率，降低GC压力

#### 2.1.4 建造者模式

#### 2.1.5 原型模式



### 2.2 结构型模式

适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

### 2.3 行为型模式

策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 2.4 简单工厂模式

#### 2.4.1 普通（单个方法）

建立生产对象的工厂类，对实现同一接口的类进行实例的创建

#### 2.4.2（多个方法）

普通方法的改进，提供多个工厂方法，分别创建对象

#### 2.4.3（多个静态方法）

将上面多个工厂方法设置为静态，不需要工厂实例，直接调用

#### 2.4.4 场景

凡需要创建多个对象时，并且具有共同的接口，可通过工厂模式进行创建。



